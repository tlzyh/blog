title: 算术指令
date: 2016-03-21
layout: post
comments: true
categories: Lua源码分析
toc: false 
tags: [Lua]
keywords: Lua, 源码阅读

---

# 0. 介绍
在Lua中，算术类指令可以说在指令集里面是很简单的。这里不像x86指令那样，因为内存
和内存之间是不能够直接进行运算操作的，所以，如果两个数在内存中的话，需要先把一
个只先取出到寄存器中，再计算两个数的结果，整个过程是比较复杂的。因为，Lua是基于
栈的虚拟机，所以，根本不存在这个复杂的操作，所有的操作可以直接在栈上就完成了。

<!--more-->

# 1. 指令集合
由于算术指格式都是一致的iABC，下面一起列出表达。

| 指令形式     | 描述                    |
|-------------|-------------------------|
| ADD    A B C | *R(A) := RK(B) + RK(C)* |
| SUB    A B C | *R(A) := RK(B) - RK(C)* |
| MUL    A B C | *R(A) := RK(B) × RK(C)* |
| DIV    A B C | *R(A) := RK(B) / RK(C)* |
| MOD    A B C | *R(A) := RK(B) % RK(C)* |
| POW    A B C | *R(A) := RK(B) ^ RK(C)* |

这里所有的操作符都是二元操作符，计算RK(B)和RK(C)的值，存放于寄存器A中，这里的
RK(B)和R(C)可能是可能是寄存器也可能是常量。

# 2. 实例
为了看看Lua中这些指令的表现形式，使用下面的Lua测试代码作为测试用例。如下：

```
local a = 4;
local b = 2;

local c = a + b;
c = 4 + b;

c = a - b;
c = a - 2;

c = a * b;

c = a / b;

c = a % b;

c = a ^ b;
```

上面这段Lua代码对应的指令如下所示：

```
        1       [1]     LOADK           0 -1    ; 4
        2       [2]     LOADK           1 -2    ; 2
        3       [4]     ADD             2 0 1
        4       [5]     ADD             2 -1 1  ; 4 -
        5       [7]     SUB             2 0 1
        6       [8]     SUB             2 0 -2  ; - 2
        7       [10]    MUL             2 0 1
        8       [12]    DIV             2 0 1
        9       [14]    MOD             2 0 1
        10      [16]    POW             2 0 1
        11      [16]    RETURN          0 1
```

从第4条指令一直到第10条指令都是算术类指令，对应上面的代码。注意到 _c = 4 + b;_
和 _c = a - 2;_ 就当成第一个常量和第二个常量就可以了。可以看到，如果RK(B)和RK(C)
是常量，那么，对应常量表中的数据，否则就是寄存器的值。

# 3. 算术指令的优化
在C语言中对于代码中两个在编译期间就知道值的两个数，会在编译的时候就计算它的值，
而不是生成对应的ADD的指令。那么，在Lua中是否也是存在这样的优化呢？先看看下面的
Lua代码会编译成什么样的指令。Lua代码如下:

```
local a = 4 + 2;
local b = 4 * 5;
a = 4 + 1 + b;
b = a + 2 * 5;
b = a + 4 - 2;
```

如果存在优化的话，最后的代码应该这样的：

```
local a = 6;
local b = 20;
a = 5 + b;
b = a + 20;
b = a + 2;
```

那么，下面就看看，编译程序列出的信息。如下：

```
        1       [32]    LOADK           0 -1    ; 6
        2       [33]    LOADK           1 -2    ; 20
        3       [34]    ADD             0 -3 1  ; 5 -
        4       [35]    ADD             1 0 -4  ; - 10
        5       [36]    ADD             2 0 -5  ; - 4
        6       [36]    SUB             1 2 -6  ; - 2
        7       [36]    RETURN          0 1
```

看到第4行中有一个加4的操作，显然，这一句都是没有被优化的。由于Lua是很轻量的一个
语言，在编译的时候没有做很复杂的优化，这里，在生产语法树的时候的处理相对简单。
为了让Lua更好优化，可以使用括号明确指出操作的优先级。最后一句改为 _b = a + (4 - 2)_
这样Lua就只会生产一条ADD指令了。

