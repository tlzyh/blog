title: 传送类指令
date: 2016-03-21
layout: post
comments: true
categories: Lua源码分析
toc: false
tags: [Lua]
keywords: Lua, 源码阅读

---

# 0. 介绍
记得在大一第一个学期学习《计算机组成原理和汇编语言》这本书的内容的时候，学习的
第一个汇编指令就是MOV指令。可以说，这个指令是计算机（包括虚拟机）指令中的基础指
令。一般虚拟机的指令和x86系列的CPU的指令有很大的差别，但是，这个指令都有。可
见他的重要性，同时，这类传送类指令比较简单。包括我毕业设计里面关于指令反汇编
也是从传送类指令开始。这里也就从这类指令开始了。我将以下5个指令归为Lua中的传送
类指令：

* OP_MOVE
* OP_LOADK
* OP_LOADKX
* OP_LOADBOOL
* OP_LOADNIL

<!--more-->

# 1. OP_MOVE
*Mov A B    描述为  R(A) := R(B)*
MOV指令有两个参数，都是两个寄存器。将B寄存器的值赋值给A。最直接的例子就是，将
一个变量的值赋值给另外一个变量，如下：

```
local a = 1;
local b = nil;
b = a;
```

那么，在第三行代码处，将产生一条Mov指令（为什么第一行不是Mov指令，后面说）。
生成的代码信息如下所示：

```
main <test.lua:0,0> (4 instructions at 008DEE08)
0+ params, 2 slots, 1 upvalue, 2 locals, 1 constant, 0 functions
        1       [23]    LOADK           0 -1    ; 1
        2       [24]    LOADNIL         1 0
        3       [25]    MOVE            1 0
        4       [25]    RETURN          0 1
```

从上面的信息可以看到，第一条指令将1赋值给了寄存器0，第二条指令把寄存器1置为nil
（先不管它），第三条指令把寄存器0赋值给了寄存器1。从-l出来的信息可以很清楚，看
到各个指令，那么，它的二进制长什么样呢？使用WinHex打开，代码如下所示：

![图片](/images/lua_src/4_mov_instruction.png)

指令部分为高亮部分，前面4个字节表示指令个数（0x00000004），Mov在倒数第2处，值为
0x00000040。参见前面章节中关于Mov指令的格式和参数的使用情况可以知道，Mov指令的格
式为iABC，前面6个bit表示的是操作码，A被使用，B被使用，C是没有使用。mov的操作码
就是0x00，A为1，B为0。对应上面的表达式可以知道，指令把寄存器0赋值给了寄存器1。


在Lua中的“汇编代码”和x86的汇编相比，mov指令是很少的，但是，在汇编语言中，mov指
令实在是太多了？这是什么原因呢？因为，x86中没有那么多的寄存器，而且，有些寄存器
是不能直接进行相互操作，而lua中当前栈帧都是当前可用可见的，一些算术操作都是直接
进行的，没有必要进行数据的移动。所以，看到Lua中Mov指令就少了很多。

# 2. OP_LOADK
**LOADK A Bx    描述为  R(A) := Kst(Bx)**

该指令将常量表中的常量赋值给寄存器A。通常来说，常量就是数值，字符串。

# 3. OP_LOADKX
**LOADKX A     描述为  R(A) := Kst(extra arg)**

LOADKX是lua5.2新加入的指令。当需要生成LOADK指令时，如果需要索引的常量id超出了Bx
所能表示的有效范围，那么就生成一个LOADKX指令，取代LOADK指令，并且接下来立即生成
一个EXTRAARG指令，并用其Ax来存放这个id。5.2的这个改动使得一个函数可以处理超过
262143个常量。

# 4. OP_LOADBOOL
**LOADBOOL A B C   描述为   R(A) := (Bool)B; if (C) pc++**

这里从指令本身承担的意义来说，是很简单的，就是将一个Boolean值赋值给寄存器A，
这么说来指令应该是 *LOADBOOL A B* 。后面的C，又是什么作用的，这个和Lua如何实现
逻辑处理有关系（以后介绍）。 看看指令的描述后面还有一个 pc++（pc，为程序计数器）。
也就是说，如果C不为false（就是0），那么，跳过下一条指令。这个主要出现在a = b > c
这种类似表达式的情况下。可能这么说起来比较抽象，下面使用代码来看看，lua代码如下：

```
local a = false;
local c = 4;
local b = c > 4;
```

编译列举出的信息如下所示：

```
        1       [29]    LOADBOOL        0 0 0
        2       [30]    LOADK           1 -1    ; 4
        3       [31]    LT              1 -1 1  ; 4 -
        4       [31]    JMP             0 1     ; to 6
        5       [31]    LOADBOOL        2 0 1
        6       [31]    LOADBOOL        2 1 0
        7       [31]    RETURN          0 1
```

第一行很显然是把0寄存器设置为了0（false）。这个时候可以看到，仅仅一句 _local b = c > 4;_
竟然产生了4行代码，而且有两行是与跳转相关的（这两行后面再介绍）。这个与我想象中
的完全不一样，我认为，应该是通过 _c > 4;_ 这个表达式求得一个boolean值，再通过指令
LOADBOOL赋值给对应的寄存器。

可以看到，指令执行到了JMP这一句，后来就跳到了第六条指令。那么，如果LT指令没有
通过，那么它会到第5行，又因为LOADBOOL中的C大于0，跳过下一条指令。这个时候，其实
可以看到Lua把 _c > 4;_ 这行代码转换为了一个 _if else_ 的语句。

# 5. OP_LOADNIL
**LOADNIL A B	R(A)   描述为   R(A), ..., R(A+B) := nil**

这个指令也就是把 R(A + 1) 到 R(A + B)的寄存器都设置为nil值。也就是说，R(B) 中存放的是寄存器的个数 - 1。那么，试想一下下面这段代码会产生什么样的指令呢？

```
local e = 1;
local a, b, c, d;
local f = nil;
local g = 1;
local h = nil;
```

按照上面的分析，那么应该是 **LOADNILL 1 4**，因为第一个寄存器已经被变量a占用了，

下面看看实际的效果是什么样的。如下:

```
        1       [18]    LOADK           0 -1    ; 1
        2       [19]    LOADNIL         1 4
        3       [21]    LOADK           6 -1    ; 1
        4       [22]    LOADNIL         7 0
        5       [22]    RETURN          0 1
```

完全一致，非常简单。不过从生成的指令中可以看到，将初始值为nil的变量全部写在一起
（中间不要插入其他非nil变量），效率会比较高。

**注意** : 在lua的源代码中 R(A), ..., R(A+B) := nil 被描述为了 R(A + 1), ..., R(A+B) := nil
是存在错误的。

